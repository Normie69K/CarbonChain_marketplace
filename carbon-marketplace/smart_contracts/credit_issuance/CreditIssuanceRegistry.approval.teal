#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 2 32
    bytecblock "total_credits_issued" "issuer_verified" "issuer_credits" 0x151f7c75 "admin"
    // smart_contracts/credit_issuance/contract.py:17
    // class CreditIssuanceRegistry(ARC4Contract):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@12
    pushbytess 0x7afdacd3 0xcba161e6 0x14339df0 0x25fd8d69 0x317cc6e2 0x5fd22bea // method "register_issuer(string,string,string)void", method "verify_issuer(address)void", method "mint_carbon_credit(string,string,string,uint64,uint64,string,string)uint64", method "get_credit_asset_id(string)uint64", method "get_issuer_stats(address)(uint64,uint64)", method "get_total_issued()uint64"
    txna ApplicationArgs 0
    match register_issuer verify_issuer mint_carbon_credit get_credit_asset_id get_issuer_stats get_total_issued
    err

main_create_NoOp@12:
    // smart_contracts/credit_issuance/contract.py:17
    // class CreditIssuanceRegistry(ARC4Contract):
    pushbytes 0x9c4a59bd // method "create_registry()void"
    txna ApplicationArgs 0
    match create_registry
    err


// smart_contracts.credit_issuance.contract.CreditIssuanceRegistry.create_registry[routing]() -> void:
create_registry:
    // smart_contracts/credit_issuance/contract.py:36
    // self.admin.value = Txn.sender
    bytec 4 // "admin"
    txn Sender
    app_global_put
    // smart_contracts/credit_issuance/contract.py:37
    // self.total_credits_issued.value = UInt64(0)
    bytec_0 // "total_credits_issued"
    intc_0 // 0
    app_global_put
    // smart_contracts/credit_issuance/contract.py:33
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    intc_1 // 1
    return


// smart_contracts.credit_issuance.contract.CreditIssuanceRegistry.register_issuer[routing]() -> void:
register_issuer:
    // smart_contracts/credit_issuance/contract.py:40
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/credit_issuance/contract.py:52
    // self.issuer_name[Txn.sender]     = name.bytes
    txn Sender
    pushbytes "issuer_name"
    uncover 3
    app_local_put
    // smart_contracts/credit_issuance/contract.py:53
    // self.issuer_standard[Txn.sender] = verification_standard.bytes
    txn Sender
    pushbytes "issuer_standard"
    uncover 2
    app_local_put
    // smart_contracts/credit_issuance/contract.py:54
    // self.issuer_verified[Txn.sender] = UInt64(0)
    txn Sender
    bytec_1 // "issuer_verified"
    intc_0 // 0
    app_local_put
    // smart_contracts/credit_issuance/contract.py:55
    // self.issuer_credits[Txn.sender]  = UInt64(0)
    txn Sender
    bytec_2 // "issuer_credits"
    intc_0 // 0
    app_local_put
    // smart_contracts/credit_issuance/contract.py:40
    // @arc4.abimethod
    intc_1 // 1
    return


// smart_contracts.credit_issuance.contract.CreditIssuanceRegistry.verify_issuer[routing]() -> void:
verify_issuer:
    // smart_contracts/credit_issuance/contract.py:58
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/credit_issuance/contract.py:61
    // assert Txn.sender == self.admin.value, "Admin only"
    txn Sender
    intc_0 // 0
    bytec 4 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Admin only
    // smart_contracts/credit_issuance/contract.py:62
    // self.issuer_verified[issuer.native] = UInt64(1)
    bytec_1 // "issuer_verified"
    intc_1 // 1
    app_local_put
    // smart_contracts/credit_issuance/contract.py:58
    // @arc4.abimethod
    intc_1 // 1
    return


// smart_contracts.credit_issuance.contract.CreditIssuanceRegistry.mint_carbon_credit[routing]() -> void:
mint_carbon_credit:
    // smart_contracts/credit_issuance/contract.py:65
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 4
    dup
    len
    pushint 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 5
    dup
    len
    pushint 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 6
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 7
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/credit_issuance/contract.py:83
    // assert self.issuer_verified[Txn.sender] == UInt64(1), "Issuer not verified"
    txn Sender
    intc_0 // 0
    bytec_1 // "issuer_verified"
    app_local_get_ex
    assert // check self.issuer_verified exists for account
    intc_1 // 1
    ==
    assert // Issuer not verified
    // smart_contracts/credit_issuance/contract.py:84
    // assert co2_tonnes.native > UInt64(0), "Must represent CO2"
    uncover 2
    btoi
    dup
    assert // Must represent CO2
    // smart_contracts/credit_issuance/contract.py:85
    // assert vintage_year.native >= UInt64(2000), "Invalid vintage year"
    uncover 2
    btoi
    dup
    pushint 2000
    >=
    assert // Invalid vintage year
    // smart_contracts/credit_issuance/contract.py:87-89
    // # Reject duplicate project IDs
    // # Box.get returns (value, exists)
    // box_value, box_exists = op.Box.get(project_id.bytes)
    dig 4
    box_len
    bury 1
    // smart_contracts/credit_issuance/contract.py:90
    // assert not box_exists, "Project ID already exists"
    !
    assert // Project ID already exists
    // smart_contracts/credit_issuance/contract.py:92-105
    // # Create the NFT on Algorand
    // asset_txn = itxn.AssetConfig(
    //     total          = 1,
    //     decimals       = 0,
    //     unit_name      = b"CCT",
    //     asset_name     = project_name.bytes,
    //     url            = b"ipfs://" + ipfs_hash.bytes,
    //     manager        = Global.current_application_address,
    //     reserve        = Txn.sender,
    //     freeze         = Global.current_application_address,
    //     clawback       = Global.current_application_address,
    //     default_frozen = False,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/credit_issuance/contract.py:104
    // fee            = Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/credit_issuance/contract.py:98
    // url            = b"ipfs://" + ipfs_hash.bytes,
    pushbytes 0x697066733a2f2f
    uncover 4
    concat
    // smart_contracts/credit_issuance/contract.py:99
    // manager        = Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/credit_issuance/contract.py:100
    // reserve        = Txn.sender,
    txn Sender
    // smart_contracts/credit_issuance/contract.py:101
    // freeze         = Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/credit_issuance/contract.py:102
    // clawback       = Global.current_application_address,
    dup
    // smart_contracts/credit_issuance/contract.py:103
    // default_frozen = False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    itxn_field ConfigAssetURL
    uncover 3
    itxn_field ConfigAssetName
    // smart_contracts/credit_issuance/contract.py:96
    // unit_name      = b"CCT",
    pushbytes 0x434354
    itxn_field ConfigAssetUnitName
    // smart_contracts/credit_issuance/contract.py:95
    // decimals       = 0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // smart_contracts/credit_issuance/contract.py:94
    // total          = 1,
    intc_1 // 1
    itxn_field ConfigAssetTotal
    // smart_contracts/credit_issuance/contract.py:92-93
    // # Create the NFT on Algorand
    // asset_txn = itxn.AssetConfig(
    pushint 3 // acfg
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/credit_issuance/contract.py:92-105
    // # Create the NFT on Algorand
    // asset_txn = itxn.AssetConfig(
    //     total          = 1,
    //     decimals       = 0,
    //     unit_name      = b"CCT",
    //     asset_name     = project_name.bytes,
    //     url            = b"ipfs://" + ipfs_hash.bytes,
    //     manager        = Global.current_application_address,
    //     reserve        = Txn.sender,
    //     freeze         = Global.current_application_address,
    //     clawback       = Global.current_application_address,
    //     default_frozen = False,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/credit_issuance/contract.py:113
    // op.itob(asset_id)                 +
    itob
    // smart_contracts/credit_issuance/contract.py:114
    // op.itob(co2_tonnes.native)         +
    uncover 2
    itob
    // smart_contracts/credit_issuance/contract.py:113-114
    // op.itob(asset_id)                 +
    // op.itob(co2_tonnes.native)         +
    dig 1
    swap
    concat
    // smart_contracts/credit_issuance/contract.py:115
    // op.itob(vintage_year.native)       +
    uncover 2
    itob
    // smart_contracts/credit_issuance/contract.py:113-115
    // op.itob(asset_id)                 +
    // op.itob(co2_tonnes.native)         +
    // op.itob(vintage_year.native)       +
    concat
    // smart_contracts/credit_issuance/contract.py:116
    // op.itob(Global.latest_timestamp),
    global LatestTimestamp
    itob
    // smart_contracts/credit_issuance/contract.py:113-116
    // op.itob(asset_id)                 +
    // op.itob(co2_tonnes.native)         +
    // op.itob(vintage_year.native)       +
    // op.itob(Global.latest_timestamp),
    concat
    // smart_contracts/credit_issuance/contract.py:109-117
    // # Store metadata in box storage
    // # Layout: asset_id(8) | co2_tonnes(8) | vintage_year(8) | timestamp(8)
    // op.Box.put(
    //     project_id.bytes,
    //     op.itob(asset_id)                 +
    //     op.itob(co2_tonnes.native)         +
    //     op.itob(vintage_year.native)       +
    //     op.itob(Global.latest_timestamp),
    // )
    uncover 2
    swap
    box_put
    // smart_contracts/credit_issuance/contract.py:119
    // self.issuer_credits[Txn.sender]  = self.issuer_credits[Txn.sender] + UInt64(1)
    txn Sender
    intc_0 // 0
    bytec_2 // "issuer_credits"
    app_local_get_ex
    assert // check self.issuer_credits exists for account
    intc_1 // 1
    +
    txn Sender
    bytec_2 // "issuer_credits"
    uncover 2
    app_local_put
    // smart_contracts/credit_issuance/contract.py:120
    // self.total_credits_issued.value  = self.total_credits_issued.value  + UInt64(1)
    intc_0 // 0
    bytec_0 // "total_credits_issued"
    app_global_get_ex
    assert // check self.total_credits_issued exists
    intc_1 // 1
    +
    bytec_0 // "total_credits_issued"
    swap
    app_global_put
    // smart_contracts/credit_issuance/contract.py:65
    // @arc4.abimethod
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.credit_issuance.contract.CreditIssuanceRegistry.get_credit_asset_id[routing]() -> void:
get_credit_asset_id:
    // smart_contracts/credit_issuance/contract.py:125
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/credit_issuance/contract.py:128
    // box_value, box_exists = op.Box.get(project_id.bytes)
    box_get
    // smart_contracts/credit_issuance/contract.py:129
    // assert box_exists, "Project not found"
    assert // Project not found
    // smart_contracts/credit_issuance/contract.py:130
    // return arc4.UInt64(op.btoi(op.extract(box_value, 0, 8)))
    extract 0 8
    // smart_contracts/credit_issuance/contract.py:125
    // @arc4.abimethod(readonly=True)
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.credit_issuance.contract.CreditIssuanceRegistry.get_issuer_stats[routing]() -> void:
get_issuer_stats:
    // smart_contracts/credit_issuance/contract.py:133
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/credit_issuance/contract.py:140
    // arc4.UInt64(self.issuer_verified[issuer.native]),
    dup
    intc_0 // 0
    bytec_1 // "issuer_verified"
    app_local_get_ex
    assert // check self.issuer_verified exists for account
    itob
    // smart_contracts/credit_issuance/contract.py:141
    // arc4.UInt64(self.issuer_credits[issuer.native]),
    swap
    intc_0 // 0
    bytec_2 // "issuer_credits"
    app_local_get_ex
    assert // check self.issuer_credits exists for account
    itob
    // smart_contracts/credit_issuance/contract.py:133
    // @arc4.abimethod(readonly=True)
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.credit_issuance.contract.CreditIssuanceRegistry.get_total_issued[routing]() -> void:
get_total_issued:
    // smart_contracts/credit_issuance/contract.py:148
    // return arc4.UInt64(self.total_credits_issued.value)
    intc_0 // 0
    bytec_0 // "total_credits_issued"
    app_global_get_ex
    assert // check self.total_credits_issued exists
    itob
    // smart_contracts/credit_issuance/contract.py:145
    // @arc4.abimethod(readonly=True)
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
