#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 8 4
    bytecblock "total_volume_microalgo" "total_trades" "admin" "platform_fee_bps" 0x151f7c75
    // smart_contracts/marketplace/contract.py:16
    // class CarbonMarketplace(ARC4Contract):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@11
    pushbytess 0x43504dd9 0x0063320f 0x63d55b6c 0x16aede6e 0xe67daf51 // method "list_credit(uint64,uint64,uint64,uint64,string)void", method "buy_credit(uint64)void", method "cancel_listing(uint64)void", method "get_listing(uint64)(address,uint64,uint64,uint64)", method "get_stats()(uint64,uint64)"
    txna ApplicationArgs 0
    match list_credit buy_credit cancel_listing get_listing get_stats
    err

main_create_NoOp@11:
    // smart_contracts/marketplace/contract.py:16
    // class CarbonMarketplace(ARC4Contract):
    pushbytes 0xca0b3ceb // method "create_marketplace(uint64)void"
    txna ApplicationArgs 0
    match create_marketplace
    err


// smart_contracts.marketplace.contract.CarbonMarketplace.create_marketplace[routing]() -> void:
create_marketplace:
    // smart_contracts/marketplace/contract.py:31
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:37
    // self.admin.value                  = Txn.sender
    bytec_2 // "admin"
    txn Sender
    app_global_put
    // smart_contracts/marketplace/contract.py:38
    // self.platform_fee_bps.value       = fee_bps.native
    btoi
    bytec_3 // "platform_fee_bps"
    swap
    app_global_put
    // smart_contracts/marketplace/contract.py:39
    // self.total_volume_microalgo.value = UInt64(0)
    bytec_0 // "total_volume_microalgo"
    intc_1 // 0
    app_global_put
    // smart_contracts/marketplace/contract.py:40
    // self.total_trades.value           = UInt64(0)
    bytec_1 // "total_trades"
    intc_1 // 0
    app_global_put
    // smart_contracts/marketplace/contract.py:31
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.list_credit[routing]() -> void:
list_credit:
    // smart_contracts/marketplace/contract.py:43
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 5
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/marketplace/contract.py:61
    // assert price_microalgo.native > UInt64(0), "Price must be > 0"
    uncover 2
    btoi
    dup
    assert // Price must be > 0
    // smart_contracts/marketplace/contract.py:62
    // assert Txn.group_index > UInt64(0), "Must be in atomic group"
    txn GroupIndex
    assert // Must be in atomic group
    // smart_contracts/marketplace/contract.py:64-65
    // # Verify the previous txn sent the NFT to this contract
    // prev = gtxn.AssetTransferTransaction(Txn.group_index - UInt64(1))
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_3 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/marketplace/contract.py:66
    // assert prev.asset_receiver == Global.current_application_address, "NFT must go to contract"
    dup
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // NFT must go to contract
    // smart_contracts/marketplace/contract.py:67
    // assert prev.xfer_asset.id  == asset_id.native, "Wrong asset ID"
    dup
    gtxns XferAsset
    uncover 5
    btoi
    swap
    dig 1
    ==
    assert // Wrong asset ID
    // smart_contracts/marketplace/contract.py:68
    // assert prev.asset_amount   == UInt64(1), "Must send exactly 1 NFT"
    dig 1
    gtxns AssetAmount
    intc_0 // 1
    ==
    assert // Must send exactly 1 NFT
    // smart_contracts/marketplace/contract.py:69
    // assert prev.sender         == Txn.sender, "Sender mismatch"
    swap
    gtxns Sender
    txn Sender
    ==
    assert // Sender mismatch
    // smart_contracts/marketplace/contract.py:75
    // op.itob(asset_id.native),
    itob
    // smart_contracts/marketplace/contract.py:76-77
    // op.itob(asset_id.native)         +   # offset 0  — 8 bytes
    // Txn.sender.bytes                 +   # offset 8  — 32 bytes
    dup
    // smart_contracts/marketplace/contract.py:77
    // Txn.sender.bytes                 +   # offset 8  — 32 bytes
    txn Sender
    // smart_contracts/marketplace/contract.py:76-77
    // op.itob(asset_id.native)         +   # offset 0  — 8 bytes
    // Txn.sender.bytes                 +   # offset 8  — 32 bytes
    concat
    // smart_contracts/marketplace/contract.py:78
    // op.itob(price_microalgo.native)  +   # offset 40 — 8 bytes
    uncover 2
    itob
    // smart_contracts/marketplace/contract.py:76-78
    // op.itob(asset_id.native)         +   # offset 0  — 8 bytes
    // Txn.sender.bytes                 +   # offset 8  — 32 bytes
    // op.itob(price_microalgo.native)  +   # offset 40 — 8 bytes
    concat
    // smart_contracts/marketplace/contract.py:79
    // op.itob(co2_tonnes.native)       +   # offset 48 — 8 bytes
    uncover 3
    btoi
    itob
    // smart_contracts/marketplace/contract.py:76-79
    // op.itob(asset_id.native)         +   # offset 0  — 8 bytes
    // Txn.sender.bytes                 +   # offset 8  — 32 bytes
    // op.itob(price_microalgo.native)  +   # offset 40 — 8 bytes
    // op.itob(co2_tonnes.native)       +   # offset 48 — 8 bytes
    concat
    // smart_contracts/marketplace/contract.py:80
    // op.itob(vintage_year.native)     +   # offset 56 — 8 bytes
    uncover 2
    btoi
    itob
    // smart_contracts/marketplace/contract.py:76-80
    // op.itob(asset_id.native)         +   # offset 0  — 8 bytes
    // Txn.sender.bytes                 +   # offset 8  — 32 bytes
    // op.itob(price_microalgo.native)  +   # offset 40 — 8 bytes
    // op.itob(co2_tonnes.native)       +   # offset 48 — 8 bytes
    // op.itob(vintage_year.native)     +   # offset 56 — 8 bytes
    concat
    // smart_contracts/marketplace/contract.py:81
    // op.itob(Global.latest_timestamp) +   # offset 64 — 8 bytes
    global LatestTimestamp
    itob
    // smart_contracts/marketplace/contract.py:76-81
    // op.itob(asset_id.native)         +   # offset 0  — 8 bytes
    // Txn.sender.bytes                 +   # offset 8  — 32 bytes
    // op.itob(price_microalgo.native)  +   # offset 40 — 8 bytes
    // op.itob(co2_tonnes.native)       +   # offset 48 — 8 bytes
    // op.itob(vintage_year.native)     +   # offset 56 — 8 bytes
    // op.itob(Global.latest_timestamp) +   # offset 64 — 8 bytes
    concat
    // smart_contracts/marketplace/contract.py:82
    // op.itob(UInt64(1)),                  # offset 72 — 8 bytes (active=1)
    intc_0 // 1
    itob
    // smart_contracts/marketplace/contract.py:76-82
    // op.itob(asset_id.native)         +   # offset 0  — 8 bytes
    // Txn.sender.bytes                 +   # offset 8  — 32 bytes
    // op.itob(price_microalgo.native)  +   # offset 40 — 8 bytes
    // op.itob(co2_tonnes.native)       +   # offset 48 — 8 bytes
    // op.itob(vintage_year.native)     +   # offset 56 — 8 bytes
    // op.itob(Global.latest_timestamp) +   # offset 64 — 8 bytes
    // op.itob(UInt64(1)),                  # offset 72 — 8 bytes (active=1)
    concat
    // smart_contracts/marketplace/contract.py:71-83
    // # Box layout:
    // # asset_id(8) | seller(32) | price(8) | co2(8) | vintage(8) | timestamp(8) | active(8)
    // # Total: 80 bytes
    // op.Box.put(
    //     op.itob(asset_id.native),
    //     op.itob(asset_id.native)         +   # offset 0  — 8 bytes
    //     Txn.sender.bytes                 +   # offset 8  — 32 bytes
    //     op.itob(price_microalgo.native)  +   # offset 40 — 8 bytes
    //     op.itob(co2_tonnes.native)       +   # offset 48 — 8 bytes
    //     op.itob(vintage_year.native)     +   # offset 56 — 8 bytes
    //     op.itob(Global.latest_timestamp) +   # offset 64 — 8 bytes
    //     op.itob(UInt64(1)),                  # offset 72 — 8 bytes (active=1)
    // )
    box_put
    // smart_contracts/marketplace/contract.py:43
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.buy_credit[routing]() -> void:
buy_credit:
    // smart_contracts/marketplace/contract.py:86
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:100
    // assert Txn.group_index > UInt64(0), "Must be in atomic group"
    txn GroupIndex
    assert // Must be in atomic group
    // smart_contracts/marketplace/contract.py:102-103
    // # Load listing from box — Box.get returns (value, exists)
    // box_value, box_exists = op.Box.get(op.itob(asset_id.native))
    btoi
    dup
    itob
    dup
    box_get
    swap
    dup
    uncover 2
    // smart_contracts/marketplace/contract.py:104
    // assert box_exists, "Listing not found"
    assert // Listing not found
    // smart_contracts/marketplace/contract.py:106
    // seller = Account(op.extract(box_value, 8,  32))
    dup
    extract 8 32
    // smart_contracts/marketplace/contract.py:107
    // price  = op.btoi(op.extract(box_value, 40, 8))
    dig 1
    pushint 40
    extract_uint64
    dup
    cover 2
    cover 3
    // smart_contracts/marketplace/contract.py:108
    // active = op.btoi(op.extract(box_value, 72, 8))
    uncover 2
    pushint 72
    extract_uint64
    // smart_contracts/marketplace/contract.py:110
    // assert active == UInt64(1), "Listing is not active"
    intc_0 // 1
    ==
    assert // Listing is not active
    // smart_contracts/marketplace/contract.py:112-113
    // # Verify the payment transaction
    // pay = gtxn.PaymentTransaction(Txn.group_index - UInt64(1))
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/marketplace/contract.py:114
    // assert pay.sender   == Txn.sender,                              "Payment sender mismatch"
    dup
    gtxns Sender
    txn Sender
    ==
    assert // Payment sender mismatch
    // smart_contracts/marketplace/contract.py:115
    // assert pay.receiver == Global.current_application_address,      "Payment must go to contract"
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must go to contract
    // smart_contracts/marketplace/contract.py:116
    // assert pay.amount   == price,                                   "Payment must match listing price"
    gtxns Amount
    dig 2
    ==
    assert // Payment must match listing price
    // smart_contracts/marketplace/contract.py:118-119
    // # Calculate fee split
    // platform_fee  = (price * self.platform_fee_bps.value) // UInt64(10000)
    intc_1 // 0
    bytec_3 // "platform_fee_bps"
    app_global_get_ex
    assert // check self.platform_fee_bps exists
    dig 2
    *
    pushint 10000
    /
    dup
    cover 3
    // smart_contracts/marketplace/contract.py:120
    // seller_payout = price - platform_fee
    uncover 2
    dig 1
    -
    // smart_contracts/marketplace/contract.py:122-127
    // # Pay seller
    // itxn.Payment(
    //     receiver = seller,
    //     amount   = seller_payout,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:126
    // fee      = Global.min_txn_fee,
    global MinTxnFee
    swap
    itxn_field Amount
    uncover 2
    itxn_field Receiver
    // smart_contracts/marketplace/contract.py:122-123
    // # Pay seller
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:122-127
    // # Pay seller
    // itxn.Payment(
    //     receiver = seller,
    //     amount   = seller_payout,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/marketplace/contract.py:129-130
    // # Pay platform fee to admin
    // if platform_fee > UInt64(0):
    bz buy_credit_after_if_else@5
    // smart_contracts/marketplace/contract.py:131-135
    // itxn.Payment(
    //     receiver = self.admin.value,
    //     amount   = platform_fee,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:134
    // fee      = Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/marketplace/contract.py:132
    // receiver = self.admin.value,
    intc_1 // 0
    bytec_2 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    dig 2
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/marketplace/contract.py:131
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:131-135
    // itxn.Payment(
    //     receiver = self.admin.value,
    //     amount   = platform_fee,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_submit

buy_credit_after_if_else@5:
    // smart_contracts/marketplace/contract.py:137-143
    // # Transfer NFT to buyer
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = Txn.sender,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:142
    // fee            = Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/marketplace/contract.py:140
    // asset_receiver = Txn.sender,
    txn Sender
    // smart_contracts/marketplace/contract.py:141
    // asset_amount   = 1,
    intc_0 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dig 5
    itxn_field XferAsset
    // smart_contracts/marketplace/contract.py:137-138
    // # Transfer NFT to buyer
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:137-143
    // # Transfer NFT to buyer
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = Txn.sender,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/marketplace/contract.py:148
    // op.extract(box_value, 0, 72) + op.itob(UInt64(0)),
    dig 2
    extract 0 72
    intc_1 // 0
    itob
    concat
    // smart_contracts/marketplace/contract.py:145-149
    // # Mark listing as sold — keep first 72 bytes, set active = 0
    // op.Box.put(
    //     op.itob(asset_id.native),
    //     op.extract(box_value, 0, 72) + op.itob(UInt64(0)),
    // )
    dig 4
    swap
    box_put
    // smart_contracts/marketplace/contract.py:151
    // self.total_volume_microalgo.value = self.total_volume_microalgo.value + price
    intc_1 // 0
    bytec_0 // "total_volume_microalgo"
    app_global_get_ex
    assert // check self.total_volume_microalgo exists
    dig 2
    +
    bytec_0 // "total_volume_microalgo"
    swap
    app_global_put
    // smart_contracts/marketplace/contract.py:152
    // self.total_trades.value           = self.total_trades.value + UInt64(1)
    intc_1 // 0
    bytec_1 // "total_trades"
    app_global_get_ex
    assert // check self.total_trades exists
    intc_0 // 1
    +
    bytec_1 // "total_trades"
    swap
    app_global_put
    // smart_contracts/marketplace/contract.py:86
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.cancel_listing[routing]() -> void:
cancel_listing:
    // smart_contracts/marketplace/contract.py:155
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:161
    // box_value, box_exists = op.Box.get(op.itob(asset_id.native))
    btoi
    dup
    itob
    dup
    box_get
    // smart_contracts/marketplace/contract.py:162
    // assert box_exists, "Listing not found"
    assert // Listing not found
    // smart_contracts/marketplace/contract.py:164
    // seller = Account(op.extract(box_value, 8,  32))
    dup
    extract 8 32
    // smart_contracts/marketplace/contract.py:165
    // active = op.btoi(op.extract(box_value, 72, 8))
    dig 1
    pushint 72
    extract_uint64
    // smart_contracts/marketplace/contract.py:167
    // assert Txn.sender == seller, "Only seller can cancel"
    txn Sender
    dig 2
    ==
    assert // Only seller can cancel
    // smart_contracts/marketplace/contract.py:168
    // assert active     == UInt64(1), "Listing not active"
    intc_0 // 1
    ==
    assert // Listing not active
    // smart_contracts/marketplace/contract.py:170-176
    // # Return NFT to seller
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = seller,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:175
    // fee            = Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/marketplace/contract.py:174
    // asset_amount   = 1,
    intc_0 // 1
    itxn_field AssetAmount
    swap
    itxn_field AssetReceiver
    uncover 3
    itxn_field XferAsset
    // smart_contracts/marketplace/contract.py:170-171
    // # Return NFT to seller
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:170-176
    // # Return NFT to seller
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = seller,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/marketplace/contract.py:181
    // op.extract(box_value, 0, 72) + op.itob(UInt64(0)),
    extract 0 72
    intc_1 // 0
    itob
    concat
    // smart_contracts/marketplace/contract.py:178-182
    // # Mark inactive
    // op.Box.put(
    //     op.itob(asset_id.native),
    //     op.extract(box_value, 0, 72) + op.itob(UInt64(0)),
    // )
    box_put
    // smart_contracts/marketplace/contract.py:155
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.get_listing[routing]() -> void:
get_listing:
    // smart_contracts/marketplace/contract.py:185
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:195
    // box_value, box_exists = op.Box.get(op.itob(asset_id.native))
    btoi
    itob
    box_get
    // smart_contracts/marketplace/contract.py:196
    // assert box_exists, "Listing not found"
    assert // Listing not found
    // smart_contracts/marketplace/contract.py:199
    // arc4.Address(op.extract(box_value, 8,  32)),
    dup
    extract 8 32
    // smart_contracts/marketplace/contract.py:200
    // arc4.UInt64(op.btoi(op.extract(box_value, 40, 8))),
    dig 1
    extract 40 8
    // smart_contracts/marketplace/contract.py:201
    // arc4.UInt64(op.btoi(op.extract(box_value, 48, 8))),
    dig 2
    extract 48 8
    // smart_contracts/marketplace/contract.py:202
    // arc4.UInt64(op.btoi(op.extract(box_value, 72, 8))),
    uncover 3
    extract 72 8
    // smart_contracts/marketplace/contract.py:185
    // @arc4.abimethod(readonly=True)
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.get_stats[routing]() -> void:
get_stats:
    // smart_contracts/marketplace/contract.py:210
    // arc4.UInt64(self.total_volume_microalgo.value // UInt64(1_000_000)),
    intc_1 // 0
    bytec_0 // "total_volume_microalgo"
    app_global_get_ex
    assert // check self.total_volume_microalgo exists
    pushint 1000000
    /
    itob
    // smart_contracts/marketplace/contract.py:211
    // arc4.UInt64(self.total_trades.value),
    intc_1 // 0
    bytec_1 // "total_trades"
    app_global_get_ex
    assert // check self.total_trades exists
    itob
    // smart_contracts/marketplace/contract.py:206
    // @arc4.abimethod(readonly=True)
    concat
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return
