#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8 2
    bytecblock "total_tonnes_retired" "total_retirements" 0x151f7c75
    // smart_contracts/retirement/contract.py:15
    // class RetirementRegistry(ARC4Contract):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@9
    pushbytess 0x8839f636 0x785f1e41 0xe3fee53a // method "retire_credit(uint64,string,uint64,string)uint64", method "verify_retirement(uint64)(address,uint64,uint64)", method "get_global_stats()(uint64,uint64)"
    txna ApplicationArgs 0
    match retire_credit verify_retirement get_global_stats
    err

main_create_NoOp@9:
    // smart_contracts/retirement/contract.py:15
    // class RetirementRegistry(ARC4Contract):
    pushbytes 0x9c4a59bd // method "create_registry()void"
    txna ApplicationArgs 0
    match create_registry
    err


// smart_contracts.retirement.contract.RetirementRegistry.create_registry[routing]() -> void:
create_registry:
    // smart_contracts/retirement/contract.py:32
    // self.admin.value                = Txn.sender
    pushbytes "admin"
    txn Sender
    app_global_put
    // smart_contracts/retirement/contract.py:33
    // self.total_tonnes_retired.value = UInt64(0)
    bytec_0 // "total_tonnes_retired"
    intc_0 // 0
    app_global_put
    // smart_contracts/retirement/contract.py:34
    // self.total_retirements.value    = UInt64(0)
    bytec_1 // "total_retirements"
    intc_0 // 0
    app_global_put
    // smart_contracts/retirement/contract.py:29
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    intc_1 // 1
    return


// smart_contracts.retirement.contract.RetirementRegistry.retire_credit[routing]() -> void:
retire_credit:
    // smart_contracts/retirement/contract.py:37
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/retirement/contract.py:55
    // assert co2_tonnes.native > UInt64(0), "Invalid tonnes"
    btoi
    dup
    assert // Invalid tonnes
    // smart_contracts/retirement/contract.py:57
    // retirement_time = Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/retirement/contract.py:59-66
    // # Step 1 — Clawback NFT from company wallet back to contract
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_sender   = Txn.sender,
    //     asset_receiver = Global.current_application_address,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/retirement/contract.py:65
    // fee            = Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/retirement/contract.py:61
    // xfer_asset     = Asset(asset_id.native),
    uncover 3
    btoi
    // smart_contracts/retirement/contract.py:62
    // asset_sender   = Txn.sender,
    txn Sender
    // smart_contracts/retirement/contract.py:63
    // asset_receiver = Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/retirement/contract.py:64
    // asset_amount   = 1,
    intc_1 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field AssetSender
    dup
    itxn_field XferAsset
    // smart_contracts/retirement/contract.py:59-60
    // # Step 1 — Clawback NFT from company wallet back to contract
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    swap
    itxn_field Fee
    // smart_contracts/retirement/contract.py:59-66
    // # Step 1 — Clawback NFT from company wallet back to contract
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_sender   = Txn.sender,
    //     asset_receiver = Global.current_application_address,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/retirement/contract.py:68-73
    // # Step 2 — Destroy the ASA permanently
    // # Calling AssetConfig with no fields = destroy
    // itxn.AssetConfig(
    //     config_asset = Asset(asset_id.native),
    //     fee          = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/retirement/contract.py:72
    // fee          = Global.min_txn_fee,
    global MinTxnFee
    dig 1
    itxn_field ConfigAsset
    // smart_contracts/retirement/contract.py:68-70
    // # Step 2 — Destroy the ASA permanently
    // # Calling AssetConfig with no fields = destroy
    // itxn.AssetConfig(
    pushint 3 // acfg
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/retirement/contract.py:68-73
    // # Step 2 — Destroy the ASA permanently
    // # Calling AssetConfig with no fields = destroy
    // itxn.AssetConfig(
    //     config_asset = Asset(asset_id.native),
    //     fee          = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/retirement/contract.py:80
    // op.itob(asset_id.native),
    itob
    // smart_contracts/retirement/contract.py:81-82
    // op.itob(asset_id.native)   +   # offset 0  — 8 bytes
    // Txn.sender.bytes           +   # offset 8  — 32 bytes  (company wallet)
    dup
    // smart_contracts/retirement/contract.py:82
    // Txn.sender.bytes           +   # offset 8  — 32 bytes  (company wallet)
    txn Sender
    // smart_contracts/retirement/contract.py:81-82
    // op.itob(asset_id.native)   +   # offset 0  — 8 bytes
    // Txn.sender.bytes           +   # offset 8  — 32 bytes  (company wallet)
    concat
    // smart_contracts/retirement/contract.py:83
    // op.itob(co2_tonnes.native) +   # offset 40 — 8 bytes
    dig 3
    itob
    // smart_contracts/retirement/contract.py:81-83
    // op.itob(asset_id.native)   +   # offset 0  — 8 bytes
    // Txn.sender.bytes           +   # offset 8  — 32 bytes  (company wallet)
    // op.itob(co2_tonnes.native) +   # offset 40 — 8 bytes
    concat
    // smart_contracts/retirement/contract.py:84
    // op.itob(retirement_time)   +   # offset 48 — 8 bytes
    uncover 2
    itob
    // smart_contracts/retirement/contract.py:81-84
    // op.itob(asset_id.native)   +   # offset 0  — 8 bytes
    // Txn.sender.bytes           +   # offset 8  — 32 bytes  (company wallet)
    // op.itob(co2_tonnes.native) +   # offset 40 — 8 bytes
    // op.itob(retirement_time)   +   # offset 48 — 8 bytes
    swap
    dig 1
    concat
    // smart_contracts/retirement/contract.py:85
    // Txn.tx_id,                     # offset 56 — 32 bytes  (transaction proof)
    txn TxID
    // smart_contracts/retirement/contract.py:81-85
    // op.itob(asset_id.native)   +   # offset 0  — 8 bytes
    // Txn.sender.bytes           +   # offset 8  — 32 bytes  (company wallet)
    // op.itob(co2_tonnes.native) +   # offset 40 — 8 bytes
    // op.itob(retirement_time)   +   # offset 48 — 8 bytes
    // Txn.tx_id,                     # offset 56 — 32 bytes  (transaction proof)
    concat
    // smart_contracts/retirement/contract.py:75-86
    // # Step 3 — Write retirement record to box storage
    // # Box key   = asset_id (8 bytes) — unique per credit
    // # Box value = asset_id(8) | company_address(32) | co2_tonnes(8) | timestamp(8) | txn_id(32)
    // # Total     = 88 bytes
    // op.Box.put(
    //     op.itob(asset_id.native),
    //     op.itob(asset_id.native)   +   # offset 0  — 8 bytes
    //     Txn.sender.bytes           +   # offset 8  — 32 bytes  (company wallet)
    //     op.itob(co2_tonnes.native) +   # offset 40 — 8 bytes
    //     op.itob(retirement_time)   +   # offset 48 — 8 bytes
    //     Txn.tx_id,                     # offset 56 — 32 bytes  (transaction proof)
    // )
    uncover 2
    swap
    box_put
    // smart_contracts/retirement/contract.py:90
    // self.total_tonnes_retired.value + co2_tonnes.native
    intc_0 // 0
    bytec_0 // "total_tonnes_retired"
    app_global_get_ex
    assert // check self.total_tonnes_retired exists
    uncover 2
    +
    // smart_contracts/retirement/contract.py:88-89
    // # Update global stats
    // self.total_tonnes_retired.value = (
    bytec_0 // "total_tonnes_retired"
    // smart_contracts/retirement/contract.py:88-91
    // # Update global stats
    // self.total_tonnes_retired.value = (
    //     self.total_tonnes_retired.value + co2_tonnes.native
    // )
    swap
    app_global_put
    // smart_contracts/retirement/contract.py:92
    // self.total_retirements.value = self.total_retirements.value + UInt64(1)
    intc_0 // 0
    bytec_1 // "total_retirements"
    app_global_get_ex
    assert // check self.total_retirements exists
    intc_1 // 1
    +
    bytec_1 // "total_retirements"
    swap
    app_global_put
    // smart_contracts/retirement/contract.py:37
    // @arc4.abimethod
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.retirement.contract.RetirementRegistry.verify_retirement[routing]() -> void:
verify_retirement:
    // smart_contracts/retirement/contract.py:97
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/retirement/contract.py:108
    // box_value, box_exists = op.Box.get(op.itob(asset_id.native))
    btoi
    itob
    box_get
    // smart_contracts/retirement/contract.py:109
    // assert box_exists, "Retirement certificate not found"
    assert // Retirement certificate not found
    // smart_contracts/retirement/contract.py:112
    // arc4.Address(op.extract(box_value, 8,  32)),
    dup
    extract 8 32
    // smart_contracts/retirement/contract.py:113
    // arc4.UInt64(op.btoi(op.extract(box_value, 40, 8))),
    dig 1
    extract 40 8
    // smart_contracts/retirement/contract.py:114
    // arc4.UInt64(op.btoi(op.extract(box_value, 48, 8))),
    uncover 2
    extract 48 8
    // smart_contracts/retirement/contract.py:97
    // @arc4.abimethod(readonly=True)
    cover 2
    concat
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.retirement.contract.RetirementRegistry.get_global_stats[routing]() -> void:
get_global_stats:
    // smart_contracts/retirement/contract.py:122
    // arc4.UInt64(self.total_tonnes_retired.value),
    intc_0 // 0
    bytec_0 // "total_tonnes_retired"
    app_global_get_ex
    assert // check self.total_tonnes_retired exists
    itob
    // smart_contracts/retirement/contract.py:123
    // arc4.UInt64(self.total_retirements.value),
    intc_0 // 0
    bytec_1 // "total_retirements"
    app_global_get_ex
    assert // check self.total_retirements exists
    itob
    // smart_contracts/retirement/contract.py:118
    // @arc4.abimethod(readonly=True)
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
